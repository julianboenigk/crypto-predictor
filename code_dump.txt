===== FILE: ./configs/universe.yaml =====
pairs: ["BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "XRPUSDT", "ADAUSDT"]
interval: "15m"
max_input_age_sec: 120

===== FILE: ./pyproject.toml =====
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "crypto-predictor"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = ["PyYAML>=6.0.1", "requests>=2.32"]

[tool.ruff]
line-length = 100

[tool.mypy]
python_version = "3.12"
strict = true

[tool.pytest.ini_options]
pythonpath = ["src"]

===== FILE: ./.pytest_cache/README.md =====
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

===== FILE: ./pytest.ini =====
[pytest]
pythonpath = src


===== FILE: ./scripts/run_once.sh =====
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."
source .venv/bin/activate
python -m src.app.main run

===== FILE: ./src/agents/base.py =====
from __future__ import annotations
from typing import Protocol, Sequence, TypedDict

class Candle(TypedDict):
    t: int
    o: float
    h: float
    low: float
    c: float
    v: float

class AgentResult(TypedDict):
    pair: str
    score: float
    confidence: float
    explanation: str
    inputs_fresh: bool
    latency_ms: int

class Agent(Protocol):
    def run(self, pair: str, candles: Sequence[Candle], inputs_fresh: bool) -> AgentResult: ...

===== FILE: ./src/agents/__init__.py =====

===== FILE: ./src/agents/technical.py =====
from __future__ import annotations
import time
from typing import Sequence
from src.agents.base import Agent, Candle, AgentResult
from src.core.indicators import ema, rsi, atr


class TechnicalAgent(Agent):
    def run(self, pair: str, candles: Sequence[Candle], inputs_fresh: bool) -> AgentResult:
        t0 = time.time()
        if len(candles) < 210:
            return self._result(pair, 0.0, 0.2, "insufficient candles", inputs_fresh, t0)

        closes = [c["c"] for c in candles]
        highs  = [c["h"] for c in candles]
        lows   = [c["low"] for c in candles]

        ema200_list = ema(closes, 200)
        ema200 = ema200_list[-1] if ema200_list else None
        rsi14 = rsi(closes, 14)
        atr14 = atr(highs, lows, closes, 14)

        if ema200 is None or rsi14 is None or atr14 is None:
            return self._result(pair, 0.0, 0.2, "indicator None", inputs_fresh, t0)

        price = closes[-1]
        atr_pct = atr14 / price if price > 0 else 0.0

        # Signals
        trend = 1.0 if price > ema200 else -1.0                           # +1 long bias, -1 short bias
        rsi_sig = 0.0
        if rsi14 < 30:
            rsi_sig = +0.5
        elif 30 <= rsi14 < 45:
            rsi_sig = +0.2
        elif 55 < rsi14 <= 70:
            rsi_sig = -0.2
        elif rsi14 > 70:
            rsi_sig = -0.5

        # Score combine with weights
        score = 0.6 * trend + 0.4 * rsi_sig
        score = max(-1.0, min(1.0, score))

        # Confidence: degrade with volatility and stale inputs
        base_conf = 0.7
        vol_penalty = max(0.0, min(0.5, atr_pct * 10))  # ~0–0.5 for ~0–5% ATR
        fresh_penalty = 0.2 if not inputs_fresh else 0.0
        confidence = max(0.05, base_conf - vol_penalty - fresh_penalty)

        expl = (
            f"price={price:.2f}, ema200={ema200:.2f}, rsi14={rsi14:.1f}, atr%={atr_pct*100:.2f}, "
            f"trend={'up' if trend>0 else 'down'}, rsi_sig={rsi_sig:+.2f}"
        )
        return self._result(pair, score, confidence, expl, inputs_fresh, t0)

    def _result(self, pair: str, score: float, conf: float, expl: str, fresh: bool, t0: float) -> AgentResult:
        return {
            "pair": pair,
            "score": float(score),
            "confidence": float(conf),
            "explanation": expl,
            "inputs_fresh": bool(fresh),
            "latency_ms": int((time.time() - t0) * 1000),
        }

===== FILE: ./src/app/__init__.py =====

===== FILE: ./src/app/main.py =====
from __future__ import annotations

import argparse
import csv
from pathlib import Path
from typing import Any
from datetime import datetime, timezone

import yaml

from src.core.store import (
    init_db,
    start_run,
    end_run,
    save_agent_output,
    save_signal,
)
from src.data.binance_client import get_ohlcv
from src.agents.technical import TechnicalAgent
from src.agents.base import Candle
from src.core.consensus import decide


def load_cfg(path: str) -> dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)  # type: ignore[no-any-return]


def write_csv(pair: str, rows: list[list[float | int]]) -> Path:
    out = Path("data") / f"{pair}_15m.csv"
    out.parent.mkdir(parents=True, exist_ok=True)
    if not out.exists():
        with open(out, "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["open_time_ms", "open", "high", "low", "close", "volume", "close_time_ms"])
    if rows:
        with open(out, "a", newline="") as f:
            w = csv.writer(f)
            for r in rows:
                w.writerow(r)
    return out


def run_once() -> int:
    cfg = load_cfg("configs/universe.yaml")
    pairs = cfg["pairs"]
    interval = cfg["interval"]
    max_age = int(cfg["max_input_age_sec"]) * 1000

    init_db()
    ta = TechnicalAgent()

    started = datetime.now(timezone.utc).isoformat()
    run_id = start_run(started, notes=f"interval={interval}")

    try:
        ok_pairs = 0

        for p in pairs:
            rows, server_time = get_ohlcv(p, interval, limit=1000)

            if not rows:
                print(f"[ERROR] {p} no rows returned")
                continue

            fresh = (server_time - rows[-1][6]) <= max_age
            out = write_csv(p, rows[-100:])
            status = "FRESH" if fresh else "STALE"
            print(f"[{status}] {p} rows_appended=100 file={out}")

            # --- Technical agent ---
            last = rows[-250:]
            candles: list[Candle] = [
                {
                    "t": int(r[6]),
                    "o": float(r[1]),
                    "h": float(r[2]),
                    "low": float(r[3]),
                    "c": float(r[4]),
                    "v": float(r[5]),
                }
                for r in last
            ]
            res = ta.run(p, candles, inputs_fresh=fresh)
            print(
                f"[TECH] {p} score={res['score']:+.2f} "
                f"conf={res['confidence']:.2f} :: {res['explanation']}"
            )

            save_agent_output(
                run_id,
                p,
                "technical",
                res["score"],
                res["confidence"],
                res["explanation"],
                res["inputs_fresh"],
                res["latency_ms"],
            )

            # --- Consensus (currently only technical agent) ---
            decision = decide(
                [
                    {
                        "agent": "technical",
                        "score": res["score"],
                        "confidence": res["confidence"],
                        "explanation": res["explanation"],
                    }
                ]
            )

            save_signal(
                run_id,
                p,
                decision["consensus"],
                decision["decision"],
                decision["reason"],
            )

            print(
                f"[CONSENSUS] {p} {decision['decision']} "
                f"S={decision['consensus']:+.3f} :: {decision['reason']}"
            )

            ok_pairs += int(fresh)

        finished = datetime.now(timezone.utc).isoformat()
        status = "ok" if ok_pairs == len(pairs) else "partial"
        end_run(run_id, finished, status=status, notes=f"fresh={ok_pairs}/{len(pairs)}")
        return 0 if status == "ok" else 1

    except Exception as exc:
        finished = datetime.now(timezone.utc).isoformat()
        end_run(run_id, finished, status="error", notes=str(exc))
        raise


if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("cmd", choices=["run"], nargs="?", default="run")
    ap.parse_args()
    raise SystemExit(run_once())

===== FILE: ./src/core/consensus.py =====
from __future__ import annotations
from typing import Dict, List, TypedDict

class Vote(TypedDict):
    agent: str
    score: float        # [-1,+1]
    confidence: float   # [0,1]
    explanation: str

class Decision(TypedDict):
    consensus: float
    decision: str       # LONG | SHORT | HOLD
    reason: str

DEFAULT_THRESHOLDS = {"long": 0.4, "short": -0.4}

def decide(votes: List[Vote], weights: Dict[str, float] | None = None,
           thresholds: Dict[str, float] | None = None) -> Decision:
    if thresholds is None:
        thresholds = DEFAULT_THRESHOLDS
    if not votes:
        return {"consensus": 0.0, "decision": "HOLD", "reason": "no votes"}

    w = weights or {}
    num = 0.0
    den = 0.0
    parts: List[str] = []
    for v in votes:
        a = v["agent"]
        ww = float(w.get(a, 1.0))
        eff = v["score"] * max(0.0, min(1.0, v["confidence"]))
        num += ww * eff
        den += abs(ww)
        parts.append(f"{a}={eff:+.2f}×w{ww:g}")

    s = num / den if den > 0 else 0.0
    if s >= thresholds["long"]:
        d = "LONG"
    elif s <= thresholds["short"]:
        d = "SHORT"
    else:
        d = "HOLD"
    reason = f"S={s:+.3f} from " + ", ".join(parts)
    return {"consensus": float(s), "decision": d, "reason": reason}

===== FILE: ./src/core/indicators.py =====
from __future__ import annotations
from typing import Sequence, List


def ema(prices: Sequence[float], period: int) -> List[float]:
    if period <= 0 or len(prices) < period:
        return []
    k = 2 / (period + 1)
    out: List[float] = []
    sma = sum(prices[:period]) / period
    out.append(sma)
    ema_prev = sma
    for p in prices[period:]:
        ema_prev = p * k + ema_prev * (1 - k)
        out.append(ema_prev)
    return out


def rsi(prices: Sequence[float], period: int = 14) -> float | None:
    if len(prices) < period + 1:
        return None
    gains = []
    losses = []
    for i in range(-period, 0):
        diff = prices[i] - prices[i - 1]
        gains.append(max(diff, 0.0))
        losses.append(max(-diff, 0.0))
    avg_gain = sum(gains) / period
    avg_loss = sum(losses) / period
    if avg_loss == 0:
        return 100.0
    rs = avg_gain / avg_loss
    return 100.0 - (100.0 / (1.0 + rs))


def atr(highs: Sequence[float], lows: Sequence[float], closes: Sequence[float], period: int = 14) -> float | None:
    n = len(closes)
    if n < period + 1 or n != len(highs) or n != len(lows):
        return None
    trs: list[float] = []
    for i in range(1, n):
        tr = max(highs[i] - lows[i], abs(highs[i] - closes[i - 1]), abs(lows[i] - closes[i - 1]))
        trs.append(tr)
    if len(trs) < period:
        return None
    return sum(trs[-period:]) / period

===== FILE: ./src/core/__init__.py =====

===== FILE: ./src/core/policy.py =====
from __future__ import annotations
from typing import Sequence

def freshness_gate(inputs_fresh_flags: Sequence[bool]) -> tuple[bool, str]:
    ok = all(inputs_fresh_flags)
    return ok, "fresh" if ok else "stale inputs"

def rr_gate(r_multiple: float, min_rr: float = 1.5) -> tuple[bool, str]:
    ok = r_multiple >= min_rr
    return ok, f"R:R={r_multiple:.2f}>= {min_rr}" if ok else f"R:R={r_multiple:.2f}<{min_rr}"

===== FILE: ./src/core/store.py =====
from __future__ import annotations

import sqlite3
from pathlib import Path

DB_PATH = Path("data/signals.db")

SCHEMA = """
PRAGMA journal_mode=WAL;
CREATE TABLE IF NOT EXISTS runs(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  started_utc TEXT NOT NULL,
  finished_utc TEXT,
  status TEXT NOT NULL,
  notes TEXT
);
CREATE TABLE IF NOT EXISTS agent_outputs(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  run_id INTEGER NOT NULL,
  pair TEXT NOT NULL,
  agent TEXT NOT NULL,
  score REAL NOT NULL,
  confidence REAL NOT NULL,
  explanation TEXT NOT NULL,
  inputs_fresh INTEGER NOT NULL,
  latency_ms INTEGER NOT NULL,
  FOREIGN KEY(run_id) REFERENCES runs(id)
);
CREATE TABLE IF NOT EXISTS signals(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  run_id INTEGER NOT NULL,
  pair TEXT NOT NULL,
  consensus REAL NOT NULL,
  decision TEXT NOT NULL,
  reason TEXT NOT NULL,
  FOREIGN KEY(run_id) REFERENCES runs(id)
);
"""


def init_db() -> None:
    """Initialize SQLite database and create schema if missing."""
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    with sqlite3.connect(DB_PATH) as db:
        for stmt in SCHEMA.strip().split(";"):
            s = stmt.strip()
            if s:
                db.execute(s)


# ---------- Helpers for run logging and persistence ----------

def _conn() -> sqlite3.Connection:
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    return sqlite3.connect(DB_PATH)


def start_run(ts_utc: str, notes: str = "") -> int:
    """Insert a new run record and return its ID."""
    with _conn() as db:
        cur = db.execute(
            "INSERT INTO runs(started_utc,status,notes) VALUES(?, ?, ?)",
            (ts_utc, "running", notes),
        )
        run_id = cur.lastrowid
        assert run_id is not None, "sqlite returned None lastrowid"
        return int(run_id)


def end_run(run_id: int, ts_utc: str, status: str = "ok", notes: str = "") -> None:
    """Mark a run as finished."""
    with _conn() as db:
        db.execute(
            "UPDATE runs SET finished_utc=?, status=?, notes=? WHERE id=?",
            (ts_utc, status, notes, run_id),
        )


def save_agent_output(
    run_id: int,
    pair: str,
    agent: str,
    score: float,
    confidence: float,
    explanation: str,
    inputs_fresh: bool,
    latency_ms: int,
) -> None:
    """Store one agent's output in the database."""
    with _conn() as db:
        db.execute(
            "INSERT INTO agent_outputs(run_id,pair,agent,score,confidence,explanation,inputs_fresh,latency_ms) "
            "VALUES(?,?,?,?,?,?,?,?)",
            (
                run_id,
                pair,
                agent,
                float(score),
                float(confidence),
                explanation,
                int(inputs_fresh),
                int(latency_ms),
            ),
        )


def save_signal(run_id: int, pair: str, consensus: float, decision: str, reason: str) -> None:
    """Store the consensus signal."""
    with _conn() as db:
        db.execute(
            "INSERT INTO signals(run_id,pair,consensus,decision,reason) VALUES(?,?,?,?,?)",
            (run_id, pair, float(consensus), decision, reason),
        )

===== FILE: ./src/data/binance_client.py =====
from __future__ import annotations
from typing import List, Optional, Tuple
import time, os
import requests
from dotenv import load_dotenv

load_dotenv()  # loads .env if present

_BASE = "https://api.binance.com"
_INTERVALS = {"1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d"}

_API_KEY = os.getenv("BINANCE_API_KEY")  # optional header

def get_ohlcv(
    pair: str, interval: str, limit: int = 500, end_ms: Optional[int] = None
) -> Tuple[List[List[float | int]], int]:
    if interval not in _INTERVALS:
        raise ValueError(f"unsupported interval: {interval}")

    params: list[tuple[str, str]] = [
        ("symbol", pair),
        ("interval", interval),
        ("limit", str(min(limit, 1000))),
    ]
    if end_ms is not None:
        params.append(("endTime", str(end_ms)))

    headers = {"X-MBX-APIKEY": _API_KEY} if _API_KEY else None
    r = requests.get(f"{_BASE}/api/v3/klines", params=params, headers=headers, timeout=10)
    r.raise_for_status()
    data = r.json()

    rows: List[List[float | int]] = []
    for k in data:
        rows.append([int(k[0]), float(k[1]), float(k[2]), float(k[3]), float(k[4]), float(k[5]), int(k[6])])
    server_time = int(time.time() * 1000)
    return rows, server_time

===== FILE: ./src/data/__init__.py =====

===== FILE: ./src/__init__.py =====

===== FILE: ./tests/integration/test_binance_fetcher.py =====
from data.binance_client import get_ohlcv

def test_fetch_klines_returns_rows():
    rows, _ = get_ohlcv("BTCUSDT", "15m", limit=10)
    assert len(rows) > 0
    assert len(rows[0]) == 7

